import Foundation
import OSLog
import Combine

/// Represents an asciinema event parsed from the file
struct AsciinemaEvent {
    let timestamp: Double
    let type: String
    let data: String
}

/// File reader for asciinema format files generated by VibeTunnel
/// These files contain 100% complete terminal output without debouncing
@MainActor
class AsciinemaFileReader: ObservableObject {
    private let logger = AppLogger.fileReader

    // File monitoring
    private var fileHandle: FileHandle?
    private var filePath: String?
    private var fileObserver: DispatchSourceFileSystemObject?
    private var lastFileOffset: UInt64 = 0

    // Session metadata from header
    private var sessionWidth: Int = 80
    private var sessionHeight: Int = 24

    // Callback for new terminal output
    private var outputHandler: ((String) -> Void)?

    // State
    @Published private(set) var isReading = false
    @Published private(set) var totalEventsProcessed = 0
    @Published private(set) var lastEventTime = Date()

    /// Start reading from an asciinema file
    func startReading(sessionId: String, outputHandler: @escaping (String) -> Void) {
        logger.info("Starting asciinema reader for session: \(sessionId)")

        self.outputHandler = outputHandler

        // Construct file path
        let path = NSString(string: "~/.vibetunnel/control/\(sessionId)/stdout").expandingTildeInPath
        self.filePath = path

        logger.debug("Reading from: \(path)")

        // Open file
        guard let handle = FileHandle(forReadingAtPath: path) else {
            logger.error("Failed to open asciinema file at: \(path)")
            return
        }

        self.fileHandle = handle

        // Read header
        if let headerLine = readNextLine(from: handle) {
            parseHeader(headerLine)
        }

        // Read existing content
        readExistingContent(from: handle)

        // Set up file monitoring for new content
        setupFileMonitoring(for: path, handle: handle)

        isReading = true
        logger.info("✅ Asciinema reader started")
    }

    /// Stop reading
    func stopReading() {
        logger.info("⏹️ Stopping asciinema reader")

        fileObserver?.cancel()
        fileObserver = nil

        fileHandle?.closeFile()
        fileHandle = nil

        filePath = nil
        outputHandler = nil
        lastFileOffset = 0

        isReading = false
    }

    /// Parse the asciinema header
    private func parseHeader(_ line: String) {
        guard let data = line.data(using: .utf8),
              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {
            logger.warning("Failed to parse asciinema header")
            return
        }

        // Extract dimensions
        if let width = json["width"] as? Int {
            sessionWidth = width
        }
        if let height = json["height"] as? Int {
            sessionHeight = height
        }

        logger.debug("Session dimensions: \(self.sessionWidth)x\(self.sessionHeight)")
    }

    /// Read and process existing content in the file
    private func readExistingContent(from handle: FileHandle) {
        logger.debug("Reading existing content...")

        var outputBuffer = ""
        var eventCount = 0

        while let line = readNextLine(from: handle) {
            if let event = parseEvent(line) {
                if event.type == "o" {
                    // Accumulate output events
                    outputBuffer += event.data
                    eventCount += 1
                }
            }
        }

        // Store current file position
        lastFileOffset = handle.offsetInFile

        if !outputBuffer.isEmpty {
            logger.info("Read \(eventCount) existing events, \(outputBuffer.count) chars")

            // Send accumulated content
            outputHandler?(outputBuffer)
            totalEventsProcessed += eventCount
            lastEventTime = Date()
        }
    }

    /// Parse an asciinema event line
    private func parseEvent(_ line: String) -> AsciinemaEvent? {
        // Parse JSON array format: [timestamp, type, data]
        guard let data = line.data(using: .utf8) else { return nil }

        do {
            if let array = try JSONSerialization.jsonObject(with: data) as? [Any],
               array.count >= 3 {

                let timestamp = (array[0] as? Double) ?? 0.0
                let type = (array[1] as? String) ?? ""
                let data = (array[2] as? String) ?? ""

                return AsciinemaEvent(timestamp: timestamp, type: type, data: data)
            }
        } catch {
            // Not all lines are events (first line is header)
            return nil
        }

        return nil
    }

    /// Set up file monitoring for new content
    private func setupFileMonitoring(for path: String, handle: FileHandle) {
        logger.debug("Setting up file monitoring")

        // Create dispatch source to monitor file changes
        let fd = handle.fileDescriptor
        let source = DispatchSource.makeFileSystemObjectSource(
            fileDescriptor: fd,
            eventMask: [.write, .extend],
            queue: DispatchQueue.main
        )

        source.setEventHandler { [weak self] in
            self?.handleFileChange()
        }

        source.setCancelHandler { [weak handle] in
            handle?.closeFile()
        }

        source.resume()
        self.fileObserver = source

        logger.debug("File monitoring active")
    }

    /// Handle file change event
    private func handleFileChange() {
        guard let handle = fileHandle else { return }

        // Seek to last read position
        handle.seek(toFileOffset: lastFileOffset)

        var outputBuffer = ""
        var eventCount = 0

        // Read new lines
        while let line = readNextLine(from: handle) {
            if let event = parseEvent(line) {
                if event.type == "o" {
                    // Accumulate output events
                    outputBuffer += event.data
                    eventCount += 1
                }
            }
        }

        // Update file position
        lastFileOffset = handle.offsetInFile

        // Send new output if any
        if !outputBuffer.isEmpty {
            logger.debug("New content: \(eventCount) events, \(outputBuffer.count) chars")

            outputHandler?(outputBuffer)
            totalEventsProcessed += eventCount
            lastEventTime = Date()
        }
    }

    /// Read next line from file handle
    private func readNextLine(from handle: FileHandle) -> String? {
        var lineData = Data()
        let newline = UInt8(0x0A) // '\n'

        while true {
            let data = handle.readData(ofLength: 1)
            if data.isEmpty {
                // End of file
                if !lineData.isEmpty {
                    return String(data: lineData, encoding: .utf8)
                }
                return nil
            }

            if data[0] == newline {
                // Found end of line
                return String(data: lineData, encoding: .utf8)
            }

            lineData.append(data)
        }
    }

    deinit {
        // Clean up resources
        fileObserver?.cancel()
        fileHandle?.closeFile()
    }
}

// MARK: - Logger Extension

extension AppLogger {
    static let fileReader = Logger(subsystem: "com.vibetunnel.talk", category: "AsciinemaFileReader")
}